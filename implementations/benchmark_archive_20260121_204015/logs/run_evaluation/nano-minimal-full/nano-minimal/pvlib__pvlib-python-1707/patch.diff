diff --git a/pvlib/iam.py b/pvlib/iam.py
index 3eaa6b4..70a9182 100644
--- a/pvlib/iam.py
+++ b/pvlib/iam.py
@@ -175,8 +175,12 @@ def physical(aoi, n=1.526, K=4.0, L=0.002, *, n_ar=None):
     n2costheta2 = n2 * costheta
 
     # reflectance of s-, p-polarized, and normal light by the first interface
-    rho12_s = ((n1costheta1 - n2costheta2) / (n1costheta1 + n2costheta2)) ** 2
-    rho12_p = ((n1costheta2 - n2costheta1) / (n1costheta2 + n2costheta1)) ** 2
+    with np.errstate(divide='ignore', invalid='ignore'):
+        rho12_s = \
+            ((n1costheta1 - n2costheta2) / (n1costheta1 + n2costheta2)) ** 2
+        rho12_p = \
+            ((n1costheta2 - n2costheta1) / (n1costheta2 + n2costheta1)) ** 2
+
     rho12_0 = ((n1 - n2) / (n1 + n2)) ** 2
 
     # transmittance through the first interface
@@ -208,13 +212,22 @@ def physical(aoi, n=1.526, K=4.0, L=0.002, *, n_ar=None):
         tau_0 *= (1 - rho23_0) / (1 - rho23_0 * rho12_0)
 
     # transmittance after absorption in the glass
-    tau_s *= np.exp(-K * L / costheta)
-    tau_p *= np.exp(-K * L / costheta)
+    with np.errstate(divide='ignore', invalid='ignore'):
+        tau_s *= np.exp(-K * L / costheta)
+        tau_p *= np.exp(-K * L / costheta)
+
     tau_0 *= np.exp(-K * L)
 
     # incidence angle modifier
     iam = (tau_s + tau_p) / 2 / tau_0
 
+    # for light coming from behind the plane, none can enter the module
+    # when n2 > 1, this is already the case
+    if np.isclose(n2, 1).any():
+        iam = np.where(aoi >= 90, 0, iam)
+        if isinstance(aoi, pd.Series):
+            iam = pd.Series(iam, index=aoi.index)
+
     return iam
 
 
@@ -293,601 +306,4 @@ def martin_ruiz(aoi, a_r=0.16):
         iam = np.where(np.abs(aoi) >= 90.0, 0.0, iam)
 
     if isinstance(aoi_input, pd.Series):
-        iam = pd.Series(iam, index=aoi_input.index)
-
-    return iam
-
-
-def martin_ruiz_diffuse(surface_tilt, a_r=0.16, c1=0.4244, c2=None):
-    '''
-    Determine the incidence angle modifiers (iam) for diffuse sky and
-    ground-reflected irradiance using the Martin and Ruiz incident angle model.
-
-    Parameters
-    ----------
-    surface_tilt: float or array-like, default 0
-        Surface tilt angles in decimal degrees.
-        The tilt angle is defined as degrees from horizontal
-        (e.g. surface facing up = 0, surface facing horizon = 90)
-        surface_tilt must be in the range [0, 180]
-
-    a_r : numeric
-        The angular losses coefficient described in equation 3 of [1]_.
-        This is an empirical dimensionless parameter. Values of a_r are
-        generally on the order of 0.08 to 0.25 for flat-plate PV modules.
-        a_r must be greater than zero.
-
-    c1 : float
-        First fitting parameter for the expressions that approximate the
-        integral of diffuse irradiance coming from different directions.
-        c1 is given as the constant 4 / 3 / pi (0.4244) in [1]_.
-
-    c2 : float
-        Second fitting parameter for the expressions that approximate the
-        integral of diffuse irradiance coming from different directions.
-        If c2 is None, it will be calculated according to the linear
-        relationship given in [3]_.
-
-    Returns
-    -------
-    iam_sky : numeric
-        The incident angle modifier for sky diffuse
-
-    iam_ground : numeric
-        The incident angle modifier for ground-reflected diffuse
-
-    Notes
-    -----
-    Sky and ground modifiers are complementary: iam_sky for tilt = 30 is
-    equal to iam_ground for tilt = 180 - 30.  For vertical surfaces,
-    tilt = 90, the two factors are equal.
-
-    References
-    ----------
-    .. [1] N. Martin and J. M. Ruiz, "Calculation of the PV modules angular
-       losses under field conditions by means of an analytical model", Solar
-       Energy Materials & Solar Cells, vol. 70, pp. 25-38, 2001.
-
-    .. [2] N. Martin and J. M. Ruiz, "Corrigendum to 'Calculation of the PV
-       modules angular losses under field conditions by means of an
-       analytical model'", Solar Energy Materials & Solar Cells, vol. 110,
-       pp. 154, 2013.
-
-    .. [3] "IEC 61853-3 Photovoltaic (PV) module performance testing and energy
-       rating - Part 3: Energy rating of PV modules". IEC, Geneva, 2018.
-
-    See Also
-    --------
-    pvlib.iam.martin_ruiz
-    pvlib.iam.physical
-    pvlib.iam.ashrae
-    pvlib.iam.interp
-    pvlib.iam.sapm
-    '''
-    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Oct. 2019
-
-    if isinstance(surface_tilt, pd.Series):
-        out_index = surface_tilt.index
-    else:
-        out_index = None
-
-    surface_tilt = np.asanyarray(surface_tilt)
-
-    # avoid undefined results for horizontal or upside-down surfaces
-    zeroang = 1e-06
-
-    surface_tilt = np.where(surface_tilt == 0, zeroang, surface_tilt)
-    surface_tilt = np.where(surface_tilt == 180, 180 - zeroang, surface_tilt)
-
-    if c2 is None:
-        # This equation is from [3] Sect. 7.2
-        c2 = 0.5 * a_r - 0.154
-
-    beta = np.radians(surface_tilt)
-    sin = np.sin
-    pi = np.pi
-    cos = np.cos
-
-    # avoid RuntimeWarnings for <, sin, and cos with nan
-    with np.errstate(invalid='ignore'):
-        # because sin(pi) isn't exactly zero
-        sin_beta = np.where(surface_tilt < 90, sin(beta), sin(pi - beta))
-
-        trig_term_sky = sin_beta + (pi - beta - sin_beta) / (1 + cos(beta))
-        trig_term_gnd = sin_beta +      (beta - sin_beta) / (1 - cos(beta))  # noqa: E222 E261 E501
-
-    iam_sky = 1 - np.exp(-(c1 + c2 * trig_term_sky) * trig_term_sky / a_r)
-    iam_gnd = 1 - np.exp(-(c1 + c2 * trig_term_gnd) * trig_term_gnd / a_r)
-
-    if out_index is not None:
-        iam_sky = pd.Series(iam_sky, index=out_index, name='iam_sky')
-        iam_gnd = pd.Series(iam_gnd, index=out_index, name='iam_ground')
-
-    return iam_sky, iam_gnd
-
-
-def interp(aoi, theta_ref, iam_ref, method='linear', normalize=True):
-    r'''
-    Determine the incidence angle modifier (IAM) by interpolating a set of
-    reference values, which are usually measured values.
-
-    Parameters
-    ----------
-    aoi : numeric
-        The angle of incidence between the module normal vector and the
-        sun-beam vector [degrees].
-
-    theta_ref : numeric
-        Vector of angles at which the IAM is known [degrees].
-
-    iam_ref : numeric
-        IAM values for each angle in ``theta_ref`` [unitless].
-
-    method : str, default 'linear'
-        Specifies the interpolation method.
-        Useful options are: 'linear', 'quadratic', 'cubic'.
-        See scipy.interpolate.interp1d for more options.
-
-    normalize : boolean, default True
-        When true, the interpolated values are divided by the interpolated
-        value at zero degrees.  This ensures that ``iam=1.0`` at normal
-        incidence.
-
-    Returns
-    -------
-    iam : numeric
-        The incident angle modifier(s) [unitless]
-
-    Notes
-    -----
-    ``theta_ref`` must have two or more points and may span any range of
-    angles. Typically there will be a dozen or more points in the range 0-90
-    degrees. Beyond the range of ``theta_ref``, IAM values are extrapolated,
-    but constrained to be non-negative.
-
-    The sign of ``aoi`` is ignored; only the magnitude is used.
-
-    See Also
-    --------
-    pvlib.iam.physical
-    pvlib.iam.ashrae
-    pvlib.iam.martin_ruiz
-    pvlib.iam.sapm
-    '''
-    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. July, 2019
-
-    from scipy.interpolate import interp1d
-
-    # Scipy doesn't give the clearest feedback, so check number of points here.
-    MIN_REF_VALS = {'linear': 2, 'quadratic': 3, 'cubic': 4, 1: 2, 2: 3, 3: 4}
-
-    if len(theta_ref) < MIN_REF_VALS.get(method, 2):
-        raise ValueError("Too few reference points defined "
-                         "for interpolation method '%s'." % method)
-
-    if np.any(np.less(iam_ref, 0)):
-        raise ValueError("Negative value(s) found in 'iam_ref'. "
-                         "This is not physically possible.")
-
-    interpolator = interp1d(theta_ref, iam_ref, kind=method,
-                            fill_value='extrapolate')
-    aoi_input = aoi
-
-    aoi = np.asanyarray(aoi)
-    aoi = np.abs(aoi)
-    iam = interpolator(aoi)
-    iam = np.clip(iam, 0, None)
-
-    if normalize:
-        iam /= interpolator(0)
-
-    if isinstance(aoi_input, pd.Series):
-        iam = pd.Series(iam, index=aoi_input.index)
-
-    return iam
-
-
-def sapm(aoi, module, upper=None):
-    r"""
-    Determine the incidence angle modifier (IAM) using the SAPM model.
-
-    Parameters
-    ----------
-    aoi : numeric
-        Angle of incidence in degrees. Negative input angles will return
-        zeros.
-
-    module : dict-like
-        A dict or Series with the SAPM IAM model parameters.
-        See the :py:func:`sapm` notes section for more details.
-
-    upper : None or float, default None
-        Upper limit on the results.
-
-    Returns
-    -------
-    iam : numeric
-        The SAPM angle of incidence loss coefficient, termed F2 in [1]_.
-
-    Notes
-    -----
-    The SAPM [1]_ traditionally does not define an upper limit on the AOI
-    loss function and values slightly exceeding 1 may exist for moderate
-    angles of incidence (15-40 degrees). However, users may consider
-    imposing an upper limit of 1.
-
-    References
-    ----------
-    .. [1] King, D. et al, 2004, "Sandia Photovoltaic Array Performance
-       Model", SAND Report 3535, Sandia National Laboratories, Albuquerque,
-       NM.
-
-    .. [2] B.H. King et al, "Procedure to Determine Coefficients for the
-       Sandia Array Performance Model (SAPM)," SAND2016-5284, Sandia
-       National Laboratories (2016).
-
-    .. [3] B.H. King et al, "Recent Advancements in Outdoor Measurement
-       Techniques for Angle of Incidence Effects," 42nd IEEE PVSC (2015).
-       DOI: 10.1109/PVSC.2015.7355849
-
-    See Also
