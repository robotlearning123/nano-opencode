{
  "pvlib__pvlib-python-1854": {
    "model_name_or_path": "anthropic/claude-sonnet-4-20250514",
    "instance_id": "pvlib__pvlib-python-1854",
    "model_patch": "diff --git a/pvlib/pvsystem.py b/pvlib/pvsystem.py\nindex c277a77..f60b328 100644\n--- a/pvlib/pvsystem.py\n+++ b/pvlib/pvsystem.py\n@@ -101,12 +101,13 @@ class PVSystem:\n \n     Parameters\n     ----------\n-    arrays : iterable of Array, optional\n-        List of arrays that are part of the system. If not specified\n-        a single array is created from the other parameters (e.g.\n-        `surface_tilt`, `surface_azimuth`). Must contain at least one Array,\n-        if length of arrays is 0 a ValueError is raised. If `arrays` is\n-        specified the following PVSystem parameters are ignored:\n+    arrays : Array or iterable of Array, optional\n+        A single Array instance or iterable of Array instances that are part\n+        of the system. If not specified a single array is created from the\n+        other parameters (e.g. `surface_tilt`, `surface_azimuth`). Must\n+        contain at least one Array, if length of arrays is 0 a ValueError is\n+        raised. If `arrays` is specified the following PVSystem parameters\n+        are ignored:\n \n         - `surface_tilt`\n         - `surface_azimuth`\n@@ -202,6 +203,10 @@ class PVSystem:\n                  inverter=None, inverter_parameters=None,\n                  racking_model=None, losses_parameters=None, name=None):\n \n+        # Check if arrays is a single Array instance and convert to tuple\n+        if isinstance(arrays, Array):\n+            arrays = (arrays,)\n+        \n         if arrays is None:\n             if losses_parameters is None:\n                 array_losses_parameters = {}\n@@ -3010,3 +3015,5 @@ def combine_loss_factors(index, *losses, fill_method='ffill'):\n         combined_factor *= (1 - loss)\n \n     return 1 - combined_factor\n+\n+\n"
  },
  "pvlib__pvlib-python-1154": {
    "model_name_or_path": "anthropic/claude-sonnet-4-20250514",
    "instance_id": "pvlib__pvlib-python-1154",
    "model_patch": "diff --git a/pvlib/irradiance.py b/pvlib/irradiance.py\nindex 6580030..cc5a74e 100644\n--- a/pvlib/irradiance.py\n+++ b/pvlib/irradiance.py\n@@ -879,6 +879,17 @@ def reindl(surface_tilt, surface_azimuth, dhi, dni, ghi, dni_extra,\n     # Anisotropy Index\n     AI = dni / dni_extra\n \n+    # When GHI is 0, return 0 immediately to avoid division by zero\n+    # This handles the edge case where GHI=0 (no solar irradiance)\n+    # The result should be 0 regardless of other input values\n+    if np.isscalar(ghi):\n+        if ghi == 0:\n+            return 0.0\n+    else:\n+        # For array inputs, we need to handle element-wise\n+        # Calculate normally and then zero out results where GHI is 0\n+        pass\n+\n     # DNI projected onto horizontal\n     HB = dni * cos_solar_zenith\n     HB = np.maximum(HB, 0)\n@@ -886,11 +897,27 @@ def reindl(surface_tilt, surface_azimuth, dhi, dni, ghi, dni_extra,\n     # these are the () and [] sub-terms of the second term of eqn 8\n     term1 = 1 - AI\n     term2 = 0.5 * (1 + tools.cosd(surface_tilt))\n-    term3 = 1 + np.sqrt(HB / ghi) * (tools.sind(0.5 * surface_tilt) ** 3)\n+\n+    # silence warning from division by zero when ghi is 0\n+    with np.errstate(invalid='ignore', divide='ignore'):\n+        term3 = 1 + np.sqrt(HB / ghi) * (tools.sind(0.5 * surface_tilt) ** 3)\n+\n+    # When GHI is 0, replace NaN/Inf with 1 (the term3 factor doesn't matter\n+    # since the result will be zeroed out below)\n+    try:\n+        # works for Series\n+        term3 = term3.fillna(1)\n+    except AttributeError:\n+        # works for numpy arrays\n+        term3 = np.where(np.isnan(term3) | np.isinf(term3), 1, term3)\n \n     sky_diffuse = dhi * (AI * Rb + term1 * term2 * term3)\n     sky_diffuse = np.maximum(sky_diffuse, 0)\n \n+    # For array inputs, ensure result is 0 where GHI is 0\n+    if not np.isscalar(ghi):\n+        sky_diffuse = np.where(ghi == 0, 0, sky_diffuse)\n+\n     return sky_diffuse\n \n \n@@ -2869,3 +2896,6 @@ def dni(ghi, dhi, zenith, clearsky_dni=None, clearsky_tolerance=1.1,\n             (zenith < zenith_threshold_for_zero_dni) &\n             (dni > max_dni)] = max_dni\n     return dni\n+\n+\n+\ndiff --git a/pvlib/pvsystem.py b/pvlib/pvsystem.py\nindex 33696bc..0550f2a 100644\n--- a/pvlib/pvsystem.py\n+++ b/pvlib/pvsystem.py\n@@ -2428,7 +2428,7 @@ def singlediode(photocurrent, saturation_current, resistance_series,\n \n \n def max_power_point(photocurrent, saturation_current, resistance_series,\n-                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                     method='brentq'):\n     \"\"\"\n     Given the single diode equation coefficients, calculates the maximum power\n@@ -2475,7 +2475,7 @@ def max_power_point(photocurrent, saturation_current, resistance_series,\n     \"\"\"\n     i_mp, v_mp, p_mp = _singlediode.bishop88_mpp(\n         photocurrent, saturation_current, resistance_series,\n-        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n         method=method.lower()\n     )\n     if isinstance(photocurrent, pd.Series):\n@@ -2844,3 +2844,5 @@ def combine_loss_factors(index, *losses, fill_method='ffill'):\n         combined_factor *= (1 - loss)\n \n     return 1 - combined_factor\n+\n+\ndiff --git a/pvlib/singlediode.py b/pvlib/singlediode.py\nindex b800e1c..e056d7d 100644\n--- a/pvlib/singlediode.py\n+++ b/pvlib/singlediode.py\n@@ -56,7 +56,7 @@ def estimate_voc(photocurrent, saturation_current, nNsVth):\n \n def bishop88(diode_voltage, photocurrent, saturation_current,\n              resistance_series, resistance_shunt, nNsVth, d2mutau=0,\n-             NsVbi=np.Inf, breakdown_factor=0., breakdown_voltage=-5.5,\n+             NsVbi=np.inf, breakdown_factor=0., breakdown_voltage=-5.5,\n              breakdown_exp=3.28, gradients=False):\n     r\"\"\"\n     Explicit calculation of points on the IV curve described by the single\n@@ -204,7 +204,7 @@ def bishop88(diode_voltage, photocurrent, saturation_current,\n \n def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -292,7 +292,7 @@ def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n \n def bishop88_v_from_i(current, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -378,7 +378,7 @@ def bishop88_v_from_i(current, photocurrent, saturation_current,\n \n \n def bishop88_mpp(photocurrent, saturation_current, resistance_series,\n-                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                  breakdown_factor=0., breakdown_voltage=-5.5,\n                  breakdown_exp=3.28, method='newton'):\n     \"\"\"\n@@ -688,3 +688,7 @@ def _pwr_optfcn(df, loc):\n                            df['nNsVth'], df[loc], df['i_0'], df['i_l'])\n \n     return I * df[loc]\n+\n+\n+\n+\n"
  }
}