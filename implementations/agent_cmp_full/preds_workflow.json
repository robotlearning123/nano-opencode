{
  "sqlfluff__sqlfluff-1625": {
    "instance_id": "sqlfluff__sqlfluff-1625",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/src/sqlfluff/rules/L031.py b/src/sqlfluff/rules/L031.py\nindex 838c6ce5d..a4d32365d 100644\n--- a/src/sqlfluff/rules/L031.py\n+++ b/src/sqlfluff/rules/L031.py\n@@ -62,6 +62,12 @@ class Rule_L031(BaseRule):\n             if not from_clause_segment:\n                 return None\n \n+            # Check if there are any join clauses. If not, skip this rule\n+            # since it's specifically about aliases in join conditions.\n+            join_clauses = list(from_clause_segment.recursive_crawl(\"join_clause\"))\n+            if not join_clauses:\n+                return None\n+\n             from_expression = from_clause_segment.get_child(\"from_expression\")\n             from_expression_element = None\n             if from_expression:\n@@ -217,3 +223,4 @@ class Rule_L031(BaseRule):\n             )\n \n         return violation_buff or None\n+\n"
  },
  "sqlfluff__sqlfluff-2419": {
    "instance_id": "sqlfluff__sqlfluff-2419",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/src/sqlfluff/rules/L060.py b/src/sqlfluff/rules/L060.py\nindex 836941edc..3993eebd2 100644\n--- a/src/sqlfluff/rules/L060.py\n+++ b/src/sqlfluff/rules/L060.py\n@@ -59,4 +59,9 @@ class Rule_L060(BaseRule):\n             ],\n         )\n \n-        return LintResult(context.segment, [fix])\n+        # Provide a specific error message based on which function was found\n+        function_name = context.segment.raw_upper\n+        description = f\"Use 'COALESCE' instead of '{function_name}'.\"\n+\n+        return LintResult(context.segment, [fix], description=description)\n+\n"
  },
  "sqlfluff__sqlfluff-1733": {
    "instance_id": "sqlfluff__sqlfluff-1733",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "sqlfluff__sqlfluff-1517": {
    "instance_id": "sqlfluff__sqlfluff-1517",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "sqlfluff__sqlfluff-1763": {
    "instance_id": "sqlfluff__sqlfluff-1763",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "marshmallow-code__marshmallow-1359": {
    "instance_id": "marshmallow-code__marshmallow-1359",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/src/marshmallow/fields.py b/src/marshmallow/fields.py\nindex 0b18e7dd..e642e0a4 100644\n--- a/src/marshmallow/fields.py\n+++ b/src/marshmallow/fields.py\n@@ -1118,6 +1118,16 @@ class DateTime(Field):\n             or self.DEFAULT_FORMAT\n         )\n \n+    def _bind_to_schema(self, field_name, schema):\n+        super()._bind_to_schema(field_name, schema)\n+        self.format = (\n+            self.format\n+            or (getattr(schema.opts, self.SCHEMA_OPTS_VAR_NAME, None)\n+                if hasattr(schema, 'opts')\n+                else None)\n+            or self.DEFAULT_FORMAT\n+        )\n+\n     def _serialize(self, value, attr, obj, **kwargs):\n         if value is None:\n             return None\n"
  },
  "marshmallow-code__marshmallow-1343": {
    "instance_id": "marshmallow-code__marshmallow-1343",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/src/marshmallow/marshalling.py b/src/marshmallow/marshalling.py\nindex feb7d1aa..4b40f0d4 100644\n--- a/src/marshmallow/marshalling.py\n+++ b/src/marshmallow/marshalling.py\n@@ -13,7 +13,7 @@ from __future__ import unicode_literals\n import collections\n \n from marshmallow.utils import is_collection, missing, set_value\n-from marshmallow.compat import text_type, iteritems\n+from marshmallow.compat import text_type, iteritems, Mapping\n from marshmallow.exceptions import (\n     ValidationError,\n )\n@@ -250,59 +250,4 @@ class Unmarshaller(ErrorStore):\n \n         ret = dict_class()\n \n-        if not isinstance(data, collections.Mapping):\n-            errors = self.get_errors(index=index)\n-            msg = 'Invalid input type.'\n-            self.error_field_names = [SCHEMA]\n-            errors = self.get_errors()\n-            errors.setdefault(SCHEMA, []).append(msg)\n-            return None\n-        else:\n-            partial_is_collection = is_collection(partial)\n-            for attr_name, field_obj in iteritems(fields_dict):\n-                if field_obj.dump_only:\n-                    continue\n-                raw_value = data.get(attr_name, missing)\n-                field_name = attr_name\n-                if raw_value is missing and field_obj.load_from:\n-                    field_name = field_obj.load_from\n-                    raw_value = data.get(field_obj.load_from, missing)\n-                if raw_value is missing:\n-                    # Ignore missing field if we're allowed to.\n-                    if (\n-                        partial is True or\n-                        (partial_is_collection and attr_name in partial)\n-                    ):\n-                        continue\n-                    _miss = field_obj.missing\n-                    raw_value = _miss() if callable(_miss) else _miss\n-                if raw_value is missing and not field_obj.required:\n-                    continue\n-\n-                getter = lambda val: field_obj.deserialize(\n-                    val,\n-                    field_obj.load_from or attr_name,\n-                    data\n-                )\n-                value = self.call_and_store(\n-                    getter_func=getter,\n-                    data=raw_value,\n-                    field_name=field_name,\n-                    field_obj=field_obj,\n-                    index=(index if index_errors else None)\n-                )\n-                if value is not missing:\n-                    key = fields_dict[attr_name].attribute or attr_name\n-                    set_value(ret, key, value)\n \n-        if self.errors and not self._pending:\n-            raise ValidationError(\n-                self.errors,\n-                field_names=self.error_field_names,\n-                fields=self.error_fields,\n-                data=ret,\n-            )\n-        return ret\n-\n-    # Make an instance callable\n-    __call__ = deserialize\n"
  },
  "pvlib__pvlib-python-1707": {
    "instance_id": "pvlib__pvlib-python-1707",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pvlib__pvlib-python-1072": {
    "instance_id": "pvlib__pvlib-python-1072",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pvlib/pvsystem.py b/pvlib/pvsystem.py\nindex fecc930..90e7397 100644\n--- a/pvlib/pvsystem.py\n+++ b/pvlib/pvsystem.py\n@@ -1942,7 +1942,7 @@ def singlediode(photocurrent, saturation_current, resistance_series,\n \n \n def max_power_point(photocurrent, saturation_current, resistance_series,\n-                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                     method='brentq'):\n     \"\"\"\n     Given the single diode equation coefficients, calculates the maximum power\n@@ -1989,7 +1989,7 @@ def max_power_point(photocurrent, saturation_current, resistance_series,\n     \"\"\"\n     i_mp, v_mp, p_mp = _singlediode.bishop88_mpp(\n         photocurrent, saturation_current, resistance_series,\n-        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n         method=method.lower()\n     )\n     if isinstance(photocurrent, pd.Series):\ndiff --git a/pvlib/singlediode.py b/pvlib/singlediode.py\nindex b800e1c..c33dd0a 100644\n--- a/pvlib/singlediode.py\n+++ b/pvlib/singlediode.py\n@@ -56,7 +56,7 @@ def estimate_voc(photocurrent, saturation_current, nNsVth):\n \n def bishop88(diode_voltage, photocurrent, saturation_current,\n              resistance_series, resistance_shunt, nNsVth, d2mutau=0,\n-             NsVbi=np.Inf, breakdown_factor=0., breakdown_voltage=-5.5,\n+             NsVbi=np.inf, breakdown_factor=0., breakdown_voltage=-5.5,\n              breakdown_exp=3.28, gradients=False):\n     r\"\"\"\n     Explicit calculation of points on the IV curve described by the single\n@@ -204,7 +204,7 @@ def bishop88(diode_voltage, photocurrent, saturation_current,\n \n def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -292,7 +292,7 @@ def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n \n def bishop88_v_from_i(current, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -378,7 +378,7 @@ def bishop88_v_from_i(current, photocurrent, saturation_current,\n \n \n def bishop88_mpp(photocurrent, saturation_current, resistance_series,\n-                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                  breakdown_factor=0., breakdown_voltage=-5.5,\n                  breakdown_exp=3.28, method='newton'):\n     \"\"\"\ndiff --git a/pvlib/temperature.py b/pvlib/temperature.py\nindex 1d98736..8214cb1 100644\n--- a/pvlib/temperature.py\n+++ b/pvlib/temperature.py\n@@ -599,7 +599,7 @@ def fuentes(poa_global, temp_air, wind_speed, noct_installed, module_height=5,\n     # n.b. the way Fuentes calculates the first timedelta makes it seem like\n     # the value doesn't matter -- rather than recreate it here, just assume\n     # it's the same as the second timedelta:\n-    timedelta_hours = np.diff(poa_global.index).astype(float) / 1e9 / 60 / 60\n+    timedelta_hours = np.diff(poa_global.index).astype('timedelta64[ns]').astype(float) / 1e9 / 60 / 60\n     timedelta_hours = np.append([timedelta_hours[0]], timedelta_hours)\n \n     tamb_array = temp_air + 273.15\ndiff --git a/pvlib/tests/test_singlediode.py b/pvlib/tests/test_singlediode.py\nindex ee20e48..a5186f4 100644\n--- a/pvlib/tests/test_singlediode.py\n+++ b/pvlib/tests/test_singlediode.py\n@@ -203,7 +203,7 @@ def test_pvsyst_recombination_loss(method, poa, temp_cell, expected, tol):\n         # other conditions with breakdown model on and recombination model off\n         (\n             (1.e-4, -5.5, 3.28),\n-            (0., np.Inf),\n+            (0., np.inf),\n             POA,\n             TCELL,\n             {\n"
  },
  "pvlib__pvlib-python-1606": {
    "instance_id": "pvlib__pvlib-python-1606",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pvlib/ivtools/sdm.py b/pvlib/ivtools/sdm.py\nindex 013e63f..4829c0e 100644\n--- a/pvlib/ivtools/sdm.py\n+++ b/pvlib/ivtools/sdm.py\n@@ -11,7 +11,38 @@ import numpy as np\n import scipy.constants\n from scipy import optimize\n from scipy.special import lambertw\n-from scipy.misc import derivative\n+\n+# derivative was removed from scipy.misc in newer versions\n+# Use a local implementation\n+def derivative(func, x0, dx=1.0, n=1, args=(), order=3):\n+    \"\"\"\n+    Simple numerical derivative implementation to replace scipy.misc.derivative\n+    \"\"\"\n+    if order < n + 1:\n+        raise ValueError(\"'order' (the number of points used for the numerical derivative) must be at least n + 1\")\n+    if order % 2 == 0:\n+        raise ValueError(\"'order' (the number of points used for the numerical derivative) must be odd\")\n+    \n+    # Pre-compute the coefficients for the centered difference formula\n+    if n == 1:\n+        if order == 3:\n+            coeffs = [-0.5, 0.0, 0.5]\n+        elif order == 5:\n+            coeffs = [1/12, -2/3, 0.0, 2/3, -1/12]\n+        else:\n+            # Fall back to simple centered difference\n+            coeffs = [-0.5, 0.0, 0.5]\n+    else:\n+        raise NotImplementedError(\"Only first derivatives are implemented\")\n+    \n+    # Compute the derivative\n+    half_width = len(coeffs) // 2\n+    val = 0.0\n+    for i, coeff in enumerate(coeffs):\n+        val += coeff * func(x0 + (i - half_width) * dx, *args)\n+    val /= dx\n+    \n+    return val\n \n from pvlib.pvsystem import calcparams_pvsyst, singlediode, v_from_i\n from pvlib.singlediode import bishop88_mpp\n@@ -276,1070 +307,4 @@ def _system_of_equations_desoto(params, specs):\n     # 1st equation - short-circuit - eq(3) in [1]\n     y[0] = Isc - IL + Io * np.expm1(Isc * Rs / a) + Isc * Rs / Rsh\n \n-    # 2nd equation - open-circuit Tref - eq(4) in [1]\n-    y[1] = -IL + Io * np.expm1(Voc / a) + Voc / Rsh\n-\n-    # 3rd equation - Imp & Vmp - eq(5) in [1]\n-    y[2] = Imp - IL + Io * np.expm1((Vmp + Imp * Rs) / a) \\\n-        + (Vmp + Imp * Rs) / Rsh\n-\n-    # 4th equation - Pmp derivated=0 - eq23.2.6 in [2]\n-    # caution: eq(6) in [1] has a sign error\n-    y[3] = Imp \\\n-        - Vmp * ((Io / a) * np.exp((Vmp + Imp * Rs) / a) + 1.0 / Rsh) \\\n-        / (1.0 + (Io * Rs / a) * np.exp((Vmp + Imp * Rs) / a) + Rs / Rsh)\n-\n-    # 5th equation - open-circuit T2 - eq (4) at temperature T2 in [1]\n-    T2 = Tref + 2\n-    Voc2 = (T2 - Tref) * beta_oc + Voc  # eq (7) in [1]\n-    a2 = a * T2 / Tref  # eq (8) in [1]\n-    IL2 = IL + alpha_sc * (T2 - Tref)  # eq (11) in [1]\n-    Eg2 = EgRef * (1 + dEgdT * (T2 - Tref))  # eq (10) in [1]\n-    Io2 = Io * (T2 / Tref)**3 * np.exp(1 / k * (EgRef/Tref - Eg2/T2))  # eq (9)\n-    y[4] = -IL2 + Io2 * np.expm1(Voc2 / a2) + Voc2 / Rsh  # eq (4) at T2\n-\n-    return y\n-\n-\n-def fit_pvsyst_sandia(ivcurves, specs, const=None, maxiter=5, eps1=1.e-3):\n-    \"\"\"\n-    Estimate parameters for the PVsyst module performance model.\n-\n-    Parameters\n-    ----------\n-    ivcurves : dict\n-        i : array\n-            One array element for each IV curve. The jth element is itself an\n-            array of current for jth IV curve (same length as v[j]) [A]\n-        v : array\n-            One array element for each IV curve. The jth element is itself an\n-            array of voltage for jth IV curve  (same length as i[j]) [V]\n-        ee : array\n-            effective irradiance for each IV curve, i.e., POA broadband\n-            irradiance adjusted by solar spectrum modifier [W / m^2]\n-        tc : array\n-            cell temperature for each IV curve [C]\n-        i_sc : array\n-            short circuit current for each IV curve [A]\n-        v_oc : array\n-            open circuit voltage for each IV curve [V]\n-        i_mp : array\n-            current at max power point for each IV curve [A]\n-        v_mp : array\n-            voltage at max power point for each IV curve [V]\n-\n-    specs : dict\n-        cells_in_series : int\n-            number of cells in series\n-        alpha_sc : float\n-            temperature coefficient of isc [A/C]\n-\n-    const : dict\n-        E0 : float\n-            effective irradiance at STC, default 1000 [W/m^2]\n-        T0 : float\n-            cell temperature at STC, default 25 [C]\n-        k : float\n-            1.38066E-23 J/K (Boltzmann's constant)\n-        q : float\n-            1.60218E-19 Coulomb (elementary charge)\n-\n-    maxiter : int, default 5\n-        input that sets the maximum number of iterations for the parameter\n-        updating part of the algorithm.\n-\n-    eps1: float, default 1e-3\n-        Tolerance for the IV curve fitting. The parameter updating stops when\n-        absolute values of the percent change in mean, max and standard\n-        deviation of Imp, Vmp and Pmp between iterations are all less than\n-        eps1, or when the number of iterations exceeds maxiter.\n-\n-    Returns\n-    -------\n-    dict\n-        I_L_ref : float\n-            light current at STC [A]\n-        I_o_ref : float\n-            dark current at STC [A]\n-        EgRef : float\n-            effective band gap at STC [eV]\n-        R_s : float\n-            series resistance at STC [ohm]\n-        R_sh_ref : float\n-            shunt resistance at STC [ohm]\n-        R_sh_0 : float\n-            shunt resistance at zero irradiance [ohm]\n-        R_sh_exp : float\n-            exponential factor defining decrease in shunt resistance with\n-            increasing effective irradiance\n-        gamma_ref : float\n-            diode (ideality) factor at STC [unitless]\n-        mu_gamma : float\n-            temperature coefficient for diode (ideality) factor [1/K]\n-        cells_in_series : int\n-            number of cells in series\n-        iph : array\n-            light current for each IV curve [A]\n-        io : array\n-            dark current for each IV curve [A]\n-        rs : array\n-            series resistance for each IV curve [ohm]\n-        rsh : array\n-            shunt resistance for each IV curve [ohm]\n-        u : array\n-            boolean for each IV curve indicating that the parameter values\n-            are deemed reasonable by the private function ``_filter_params``\n-\n-    Notes\n-    -----\n-    The PVsyst module performance model is described in [1]_, [2]_, and [3]_.\n-    The fitting method is documented in [4]_, [5]_, and [6]_.\n-    Ported from PVLib Matlab [7]_.\n-\n-    References\n-    ----------\n-    .. [1] K. Sauer, T. Roessler, C. W. Hansen, Modeling the Irradiance and\n-       Temperature Dependence of Photovoltaic Modules in PVsyst, IEEE Journal\n-       of Photovoltaics v5(1), January 2015.\n-    .. [2] A. Mermoud, PV Modules modeling, Presentation at the 2nd PV\n-       Performance Modeling Workshop, Santa Clara, CA, May 2013\n-    .. [3] A. Mermoud, T. Lejeuene, Performance Assessment of a Simulation\n-       Model for PV modules of any available technology, 25th European\n-       Photovoltaic Solar Energy Conference, Valencia, Spain, Sept. 2010\n-    .. [4] C. Hansen, Estimating Parameters for the PVsyst Version 6\n-       Photovoltaic Module Performance Model, Sandia National Laboratories\n-       Report SAND2015-8598\n-    .. [5] C. Hansen, Parameter Estimation for Single Diode Models of\n-       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n-    .. [6] C. Hansen, Estimation of Parameters for Single Diode Models using\n-        Measured IV Curves, Proc. of the 39th IEEE PVSC, June 2013.\n-    .. [7] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n-    \"\"\"\n-\n-    if const is None:\n-        const = {'E0': 1000.0, 'T0': 25.0, 'k': 1.38066e-23, 'q': 1.60218e-19}\n-\n-    ee = ivcurves['ee']\n-    tc = ivcurves['tc']\n-    tck = tc + 273.15\n-    isc = ivcurves['i_sc']\n-    voc = ivcurves['v_oc']\n-    imp = ivcurves['i_mp']\n-    vmp = ivcurves['v_mp']\n-\n-    # Cell Thermal Voltage\n-    vth = const['k'] / const['q'] * tck\n-\n-    n = len(ivcurves['v_oc'])\n-\n-    # Initial estimate of Rsh used to obtain the diode factor gamma0 and diode\n-    # temperature coefficient mu_gamma. Rsh is estimated using the co-content\n-    # integral method.\n-\n-    rsh = np.ones(n)\n-    for j in range(n):\n-        voltage, current = rectify_iv_curve(ivcurves['v'][j], ivcurves['i'][j])\n-        # initial estimate of Rsh, from integral over voltage regression\n-        # [5] Step 3a; [6] Step 3a\n-        _, _, _, rsh[j], _ = _fit_sandia_cocontent(\n-            voltage, current, vth[j] * specs['cells_in_series'])\n-\n-    gamma_ref, mu_gamma = _fit_pvsyst_sandia_gamma(voc, isc, rsh, vth, tck,\n-                                                   specs, const)\n-\n-    badgamma = np.isnan(gamma_ref) or np.isnan(mu_gamma) \\\n-        or not np.isreal(gamma_ref) or not np.isreal(mu_gamma)\n-\n-    if badgamma:\n-        raise RuntimeError(\n-            \"Failed to estimate the diode (ideality) factor parameter;\"\n-            \" aborting parameter estimation.\")\n-\n-    gamma = gamma_ref + mu_gamma * (tc - const['T0'])\n-    nnsvth = gamma * (vth * specs['cells_in_series'])\n-\n-    # For each IV curve, sequentially determine initial values for Io, Rs,\n-    # and Iph [5] Step 3a; [6] Step 3\n-    iph, io, rs, u = _initial_iv_params(ivcurves, ee, voc, isc, rsh,\n-                                        nnsvth)\n-\n-    # Update values for each IV curve to converge at vmp, imp, voc and isc\n-    iph, io, rs, rsh, u = _update_iv_params(voc, isc, vmp, imp, ee,\n-                                            iph, io, rs, rsh, nnsvth, u,\n-                                            maxiter, eps1)\n-\n-    # get single diode models from converged values for each IV curve\n-    pvsyst = _extract_sdm_params(ee, tc, iph, io, rs, rsh, gamma, u,\n-                                 specs, const, model='pvsyst')\n-    # Add parameters estimated in this function\n-    pvsyst['gamma_ref'] = gamma_ref\n-    pvsyst['mu_gamma'] = mu_gamma\n-    pvsyst['cells_in_series'] = specs['cells_in_series']\n-\n-    return pvsyst\n-\n-\n-def fit_desoto_sandia(ivcurves, specs, const=None, maxiter=5, eps1=1"
  },
  "pvlib__pvlib-python-1854": {
    "instance_id": "pvlib__pvlib-python-1854",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pvlib/pvsystem.py b/pvlib/pvsystem.py\nindex c277a77..42465ba 100644\n--- a/pvlib/pvsystem.py\n+++ b/pvlib/pvsystem.py\n@@ -2525,7 +2525,7 @@ def singlediode(photocurrent, saturation_current, resistance_series,\n \n \n def max_power_point(photocurrent, saturation_current, resistance_series,\n-                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                     method='brentq'):\n     \"\"\"\n     Given the single diode equation coefficients, calculates the maximum power\ndiff --git a/pvlib/singlediode.py b/pvlib/singlediode.py\nindex 203b20c..fcaa61c 100644\n--- a/pvlib/singlediode.py\n+++ b/pvlib/singlediode.py\n@@ -58,7 +58,7 @@ def estimate_voc(photocurrent, saturation_current, nNsVth):\n \n def bishop88(diode_voltage, photocurrent, saturation_current,\n              resistance_series, resistance_shunt, nNsVth, d2mutau=0,\n-             NsVbi=np.Inf, breakdown_factor=0., breakdown_voltage=-5.5,\n+             NsVbi=np.inf, breakdown_factor=0., breakdown_voltage=-5.5,\n              breakdown_exp=3.28, gradients=False):\n     r\"\"\"\n     Explicit calculation of points on the IV curve described by the single\n@@ -206,7 +206,7 @@ def bishop88(diode_voltage, photocurrent, saturation_current,\n \n def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton', method_kwargs=None):\n     \"\"\"\n@@ -338,7 +338,7 @@ def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n \n def bishop88_v_from_i(current, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton', method_kwargs=None):\n     \"\"\"\n@@ -469,7 +469,7 @@ def bishop88_v_from_i(current, photocurrent, saturation_current,\n \n \n def bishop88_mpp(photocurrent, saturation_current, resistance_series,\n-                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                  breakdown_factor=0., breakdown_voltage=-5.5,\n                  breakdown_exp=3.28, method='newton', method_kwargs=None):\n     \"\"\"\n"
  },
  "pvlib__pvlib-python-1154": {
    "instance_id": "pvlib__pvlib-python-1154",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pvlib/irradiance.py b/pvlib/irradiance.py\nindex 6580030..1f8efe8 100644\n--- a/pvlib/irradiance.py\n+++ b/pvlib/irradiance.py\n@@ -886,9 +886,12 @@ def reindl(surface_tilt, surface_azimuth, dhi, dni, ghi, dni_extra,\n     # these are the () and [] sub-terms of the second term of eqn 8\n     term1 = 1 - AI\n     term2 = 0.5 * (1 + tools.cosd(surface_tilt))\n-    term3 = 1 + np.sqrt(HB / ghi) * (tools.sind(0.5 * surface_tilt) ** 3)\n+    term3 = 1 + np.sqrt(HB / np.maximum(ghi, 1e-10)) * (\n+        tools.sind(0.5 * surface_tilt) ** 3)\n \n     sky_diffuse = dhi * (AI * Rb + term1 * term2 * term3)\n+    # When GHI is 0, DHI should also be 0, but ensure result is 0\n+    sky_diffuse = np.where(ghi <= 0, 0, sky_diffuse)\n     sky_diffuse = np.maximum(sky_diffuse, 0)\n \n     return sky_diffuse\ndiff --git a/pvlib/pvsystem.py b/pvlib/pvsystem.py\nindex 33696bc..9ef7dff 100644\n--- a/pvlib/pvsystem.py\n+++ b/pvlib/pvsystem.py\n@@ -2428,7 +2428,7 @@ def singlediode(photocurrent, saturation_current, resistance_series,\n \n \n def max_power_point(photocurrent, saturation_current, resistance_series,\n-                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                     method='brentq'):\n     \"\"\"\n     Given the single diode equation coefficients, calculates the maximum power\n@@ -2475,7 +2475,7 @@ def max_power_point(photocurrent, saturation_current, resistance_series,\n     \"\"\"\n     i_mp, v_mp, p_mp = _singlediode.bishop88_mpp(\n         photocurrent, saturation_current, resistance_series,\n-        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n         method=method.lower()\n     )\n     if isinstance(photocurrent, pd.Series):\ndiff --git a/pvlib/singlediode.py b/pvlib/singlediode.py\nindex b800e1c..c33dd0a 100644\n--- a/pvlib/singlediode.py\n+++ b/pvlib/singlediode.py\n@@ -56,7 +56,7 @@ def estimate_voc(photocurrent, saturation_current, nNsVth):\n \n def bishop88(diode_voltage, photocurrent, saturation_current,\n              resistance_series, resistance_shunt, nNsVth, d2mutau=0,\n-             NsVbi=np.Inf, breakdown_factor=0., breakdown_voltage=-5.5,\n+             NsVbi=np.inf, breakdown_factor=0., breakdown_voltage=-5.5,\n              breakdown_exp=3.28, gradients=False):\n     r\"\"\"\n     Explicit calculation of points on the IV curve described by the single\n@@ -204,7 +204,7 @@ def bishop88(diode_voltage, photocurrent, saturation_current,\n \n def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -292,7 +292,7 @@ def bishop88_i_from_v(voltage, photocurrent, saturation_current,\n \n def bishop88_v_from_i(current, photocurrent, saturation_current,\n                       resistance_series, resistance_shunt, nNsVth,\n-                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n+                      d2mutau=0, NsVbi=np.inf, breakdown_factor=0.,\n                       breakdown_voltage=-5.5, breakdown_exp=3.28,\n                       method='newton'):\n     \"\"\"\n@@ -378,7 +378,7 @@ def bishop88_v_from_i(current, photocurrent, saturation_current,\n \n \n def bishop88_mpp(photocurrent, saturation_current, resistance_series,\n-                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n+                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.inf,\n                  breakdown_factor=0., breakdown_voltage=-5.5,\n                  breakdown_exp=3.28, method='newton'):\n     \"\"\"\ndiff --git a/pvlib/tests/test_singlediode.py b/pvlib/tests/test_singlediode.py\nindex ee20e48..a5186f4 100644\n--- a/pvlib/tests/test_singlediode.py\n+++ b/pvlib/tests/test_singlediode.py\n@@ -203,7 +203,7 @@ def test_pvsyst_recombination_loss(method, poa, temp_cell, expected, tol):\n         # other conditions with breakdown model on and recombination model off\n         (\n             (1.e-4, -5.5, 3.28),\n-            (0., np.Inf),\n+            (0., np.inf),\n             POA,\n             TCELL,\n             {\n"
  },
  "pylint-dev__astroid-1978": {
    "instance_id": "pylint-dev__astroid-1978",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pylint-dev__astroid-1333": {
    "instance_id": "pylint-dev__astroid-1333",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pylint-dev__astroid-1196": {
    "instance_id": "pylint-dev__astroid-1196",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 11136f8c..2c6fa1b1 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -2361,9 +2361,22 @@ class Dict(NodeNG, Instance):\n             # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n             if isinstance(key, DictUnpack):\n                 try:\n-                    return value.getitem(index, context)\n-                except (AstroidTypeError, AstroidIndexError):\n-                    continue\n+                    # Try to infer the actual value being unpacked\n+                    for inferred_value in value.infer(context):\n+                        if inferred_value is util.Uninferable:\n+                            continue\n+                        # If the unpacked value is a Dict, recursively search in it\n+                        if isinstance(inferred_value, Dict):\n+                            try:\n+                                return inferred_value.getitem(index, context)\n+                            except (AstroidTypeError, AstroidIndexError):\n+                                continue\n+                        # If we can infer a value but it's not a Dict, we can't search in it\n+                        # Fall through to continue searching in other items\n+                except (InferenceError, StopIteration):\n+                    # If we can't infer the value, continue searching in other items\n+                    pass\n+                continue\n             for inferredkey in key.infer(context):\n                 if inferredkey is util.Uninferable:\n                     continue\n"
  },
  "pylint-dev__astroid-1866": {
    "instance_id": "pylint-dev__astroid-1866",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex af1ddf4d..4ea0e42b 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -954,8 +954,10 @@ def _infer_str_format_call(\n \n     try:\n         formatted_string = format_template.format(*pos_values, **keyword_values)\n-    except (IndexError, KeyError):\n+    except (IndexError, KeyError, TypeError):\n         # If there is an IndexError there are too few arguments to interpolate\n+        # If there is a KeyError, keyword argument missing\n+        # If there is a TypeError, format spec is incompatible with value type (e.g., None with :d)\n         return iter([util.Uninferable])\n \n     return iter([nodes.const_factory(formatted_string)])\n"
  },
  "pylint-dev__astroid-1268": {
    "instance_id": "pylint-dev__astroid-1268",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pyvista__pyvista-4315": {
    "instance_id": "pyvista__pyvista-4315",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pyvista/core/grid.py b/pyvista/core/grid.py\nindex 6ce23688..c06585f6 100644\n--- a/pyvista/core/grid.py\n+++ b/pyvista/core/grid.py\n@@ -72,20 +72,20 @@ class RectilinearGrid(_vtk.vtkRectilinearGrid, Grid, RectilinearGridFilters):\n \n     Parameters\n     ----------\n-    uinput : str, pathlib.Path, vtk.vtkRectilinearGrid, numpy.ndarray, optional\n+    uinput : str, pathlib.Path, vtk.vtkRectilinearGrid, numpy.ndarray, Sequence, optional\n         Filename, dataset, or array to initialize the rectilinear grid from. If a\n         filename is passed, pyvista will attempt to load it as a\n         :class:`RectilinearGrid`. If passed a ``vtk.vtkRectilinearGrid``, it\n-        will be wrapped. If a :class:`numpy.ndarray` is passed, this will be\n-        loaded as the x range.\n+        will be wrapped. If a :class:`numpy.ndarray` or :class:`Sequence` is \n+        passed, this will be loaded as the x range.\n \n-    y : numpy.ndarray, optional\n+    y : numpy.ndarray, Sequence, optional\n         Coordinates of the points in y direction. If this is passed, ``uinput``\n-        must be a :class:`numpy.ndarray`.\n+        must be a :class:`numpy.ndarray` or :class:`Sequence`.\n \n-    z : numpy.ndarray, optional\n+    z : numpy.ndarray, Sequence, optional\n         Coordinates of the points in z direction. If this is passed, ``uinput``\n-        and ``y`` must be a :class:`numpy.ndarray`.\n+        and ``y`` must be a :class:`numpy.ndarray` or :class:`Sequence`.\n \n     check_duplicates : bool, optional\n         Check for duplications in any arrays that are passed. Defaults to\n@@ -127,6 +127,10 @@ class RectilinearGrid(_vtk.vtkRectilinearGrid, Grid, RectilinearGridFilters):\n         \"\"\"Initialize the rectilinear grid.\"\"\"\n         super().__init__()\n \n+        # Helper function to check if an object is array-like (numpy array or sequence, but not string)\n+        def _is_array_like(obj):\n+            return isinstance(obj, (np.ndarray, Sequence)) and not isinstance(obj, (str, pathlib.Path))\n+\n         if len(args) == 1:\n             if isinstance(args[0], _vtk.vtkRectilinearGrid):\n                 if deep:\n@@ -135,23 +139,29 @@ class RectilinearGrid(_vtk.vtkRectilinearGrid, Grid, RectilinearGridFilters):\n                     self.shallow_copy(args[0])\n             elif isinstance(args[0], (str, pathlib.Path)):\n                 self._from_file(args[0], **kwargs)\n-            elif isinstance(args[0], np.ndarray):\n-                self._from_arrays(args[0], None, None, check_duplicates)\n+            elif _is_array_like(args[0]):\n+                x = np.asarray(args[0])\n+                self._from_arrays(x, None, None, check_duplicates)\n             else:\n                 raise TypeError(f'Type ({type(args[0])}) not understood by `RectilinearGrid`')\n \n         elif len(args) == 3 or len(args) == 2:\n-            arg0_is_arr = isinstance(args[0], np.ndarray)\n-            arg1_is_arr = isinstance(args[1], np.ndarray)\n+            arg0_is_arr = _is_array_like(args[0])\n+            arg1_is_arr = _is_array_like(args[1])\n             if len(args) == 3:\n-                arg2_is_arr = isinstance(args[2], np.ndarray)\n+                arg2_is_arr = _is_array_like(args[2])\n             else:\n                 arg2_is_arr = False\n \n             if all([arg0_is_arr, arg1_is_arr, arg2_is_arr]):\n-                self._from_arrays(args[0], args[1], args[2], check_duplicates)\n+                x = np.asarray(args[0])\n+                y = np.asarray(args[1])\n+                z = np.asarray(args[2])\n+                self._from_arrays(x, y, z, check_duplicates)\n             elif all([arg0_is_arr, arg1_is_arr]):\n-                self._from_arrays(args[0], args[1], None, check_duplicates)\n+                x = np.asarray(args[0])\n+                y = np.asarray(args[1])\n+                self._from_arrays(x, y, None, check_duplicates)\n             else:\n                 raise TypeError(\"Arguments not understood by `RectilinearGrid`.\")\n \n@@ -277,570 +287,4 @@ class RectilinearGrid(_vtk.vtkRectilinearGrid, Grid, RectilinearGridFilters):\n \n         Examples\n         --------\n-        Return the x coordinates of a RectilinearGrid.\n-\n-        >>> import numpy as np\n-        >>> import pyvista\n-        >>> xrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> yrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> zrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> grid = pyvista.RectilinearGrid(xrng, yrng, zrng)\n-        >>> grid.x\n-        array([-10.,   0.])\n-\n-        Set the x coordinates of a RectilinearGrid.\n-\n-        >>> grid.x = [-10.0, 0.0, 10.0]\n-        >>> grid.x\n-        array([-10.,   0.,  10.])\n-\n-        \"\"\"\n-        return helpers.convert_array(self.GetXCoordinates())\n-\n-    @x.setter\n-    def x(self, coords: Sequence):\n-        \"\"\"Set the coordinates along the X-direction.\"\"\"\n-        self.SetXCoordinates(helpers.convert_array(coords))\n-        self._update_dimensions()\n-        self.Modified()\n-\n-    @property\n-    def y(self) -> np.ndarray:\n-        \"\"\"Return or set the coordinates along the Y-direction.\n-\n-        Examples\n-        --------\n-        Return the y coordinates of a RectilinearGrid.\n-\n-        >>> import numpy as np\n-        >>> import pyvista\n-        >>> xrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> yrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> zrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> grid = pyvista.RectilinearGrid(xrng, yrng, zrng)\n-        >>> grid.y\n-        array([-10.,   0.])\n-\n-        Set the y coordinates of a RectilinearGrid.\n-\n-        >>> grid.y = [-10.0, 0.0, 10.0]\n-        >>> grid.y\n-        array([-10.,   0.,  10.])\n-\n-        \"\"\"\n-        return helpers.convert_array(self.GetYCoordinates())\n-\n-    @y.setter\n-    def y(self, coords: Sequence):\n-        \"\"\"Set the coordinates along the Y-direction.\"\"\"\n-        self.SetYCoordinates(helpers.convert_array(coords))\n-        self._update_dimensions()\n-        self.Modified()\n-\n-    @property\n-    def z(self) -> np.ndarray:\n-        \"\"\"Return or set the coordinates along the Z-direction.\n-\n-        Examples\n-        --------\n-        Return the z coordinates of a RectilinearGrid.\n-\n-        >>> import numpy as np\n-        >>> import pyvista\n-        >>> xrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> yrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> zrng = np.arange(-10, 10, 10, dtype=float)\n-        >>> grid = pyvista.RectilinearGrid(xrng, yrng, zrng)\n-        >>> grid.z\n-        array([-10.,   0.])\n-\n-        Set the z coordinates of a RectilinearGrid.\n-\n-        >>> grid.z = [-10.0, 0.0, 10.0]\n-        >>> grid.z\n-        array([-10.,   0.,  10.])\n-\n-        \"\"\"\n-        return helpers.convert_array(self.GetZCoordinates())\n-\n-    @z.setter\n-    def z(self, coords: Sequence):\n-        \"\"\"Set the coordinates along the Z-direction.\"\"\"\n-        self.SetZCoordinates(helpers.convert_array(coords))\n-        self._update_dimensions()\n-        self.Modified()\n-\n-    @Grid.dimensions.setter  # type: ignore\n-    def dimensions(self, dims):\n-        \"\"\"Do not let the dimensions of the RectilinearGrid be set.\"\"\"\n-        raise AttributeError(\n-            \"The dimensions of a `RectilinearGrid` are implicitly \"\n-            \"defined and thus cannot be set.\"\n-        )\n-\n-    def cast_to_structured_grid(self) -> 'pyvista.StructuredGrid':\n-        \"\"\"Cast this rectilinear grid to a structured grid.\n-\n-        Returns\n-        -------\n-        pyvista.StructuredGrid\n-            This grid as a structured grid.\n-\n-        \"\"\"\n-        alg = _vtk.vtkRectilinearGridToPointSet()\n-        alg.SetInputData(self)\n-        alg.Update()\n-        return _get_output(alg)\n-\n-\n-class UniformGrid(_vtk.vtkImageData, Grid, UniformGridFilters):\n-    \"\"\"Models datasets with uniform spacing in the three coordinate directions.\n-\n-    Can be initialized in one of several ways:\n-\n-    - Create empty grid\n-    - Initialize from a vtk.vtkImageData object\n-    - Initialize based on dimensions, cell spacing, and origin.\n-\n-    .. versionchanged:: 0.33.0\n-        First argument must now be either a path or\n-        ``vtk.vtkImageData``. Use keyword arguments to specify the\n-        dimensions, spacing, and origin of the uniform grid.\n-\n-    .. versionchanged:: 0.37.0\n-        The ``dims`` parameter has been renamed to ``dimensions``.\n-\n-    Parameters\n-    ----------\n-    uinput : str, vtk.vtkImageData, pyvista.UniformGrid, optional\n-        Filename or dataset to initialize the uniform grid from.  If\n-        set, remainder of arguments are ignored.\n-\n-    dimensions : sequence[int], optional\n-        Dimensions of the uniform grid.\n-\n-    spacing : sequence[float], default: (1.0, 1.0, 1.0)\n-        Spacing of the uniform grid in each dimension. Must be positive.\n-\n-    origin : sequence[float], default: (0.0, 0.0, 0.0)\n-        Origin of the uniform grid.\n-\n-    deep : bool, default: False\n-        Whether to deep copy a ``vtk.vtkImageData`` object.  Keyword only.\n-\n-    Examples\n-    --------\n-    Create an empty UniformGrid.\n-\n-    >>> import pyvista\n-    >>> grid = pyvista.UniformGrid()\n-\n-    Initialize from a ``vtk.vtkImageData`` object.\n-\n-    >>> import vtk\n-    >>> vtkgrid = vtk.vtkImageData()\n-    >>> grid = pyvista.UniformGrid(vtkgrid)\n-\n-    Initialize using just the grid dimensions and default\n-    spacing and origin. These must be keyword arguments.\n-\n-    >>> grid = pyvista.UniformGrid(dimensions=(10, 10, 10))\n-\n-    Initialize using dimensions and spacing.\n-\n-    >>> grid = pyvista.UniformGrid(\n-    ...     dimensions=(10, 10, 10),\n-    ...     spacing=(2, 1, 5),\n-    ... )\n-\n-    Initialize using dimensions, spacing, and an origin.\n-\n-    >>> grid = pyvista.UniformGrid(\n-    ...     dimensions=(10, 10, 10),\n-    ...     spacing=(2, 1, 5),\n-    ...     origin=(10, 35, 50),\n-    ... )\n-\n-    Initialize from another UniformGrid.\n-\n-    >>> grid = pyvista.UniformGrid(\n-    ...     dimensions=(10, 10, 10),\n-    ...     spacing=(2, 1, 5),\n-    ."
  },
  "pydicom__pydicom-1694": {
    "instance_id": "pydicom__pydicom-1694",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pydicom/dataset.py b/pydicom/dataset.py\nindex e32315011..a6f887966 100644\n--- a/pydicom/dataset.py\n+++ b/pydicom/dataset.py\n@@ -2492,8 +2492,8 @@ class Dataset:\n         json_dataset = {}\n         for key in self.keys():\n             json_key = '{:08X}'.format(key)\n-            data_element = self[key]\n             try:\n+                data_element = self[key]\n                 json_dataset[json_key] = data_element.to_json_dict(\n                     bulk_data_element_handler=bulk_data_element_handler,\n                     bulk_data_threshold=bulk_data_threshold\n"
  },
  "pydicom__pydicom-1413": {
    "instance_id": "pydicom__pydicom-1413",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pydicom__pydicom-901": {
    "instance_id": "pydicom__pydicom-901",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pydicom/config.py b/pydicom/config.py\nindex ae9c8bdf1..d5bc48cea 100644\n--- a/pydicom/config.py\n+++ b/pydicom/config.py\n@@ -62,10 +62,7 @@ and datetime.time respectively. Default: False\n \n # Logging system and debug function to change logging level\n logger = logging.getLogger('pydicom')\n-handler = logging.StreamHandler()\n-formatter = logging.Formatter(\"%(message)s\")\n-handler.setFormatter(formatter)\n-logger.addHandler(handler)\n+debugging = False\n \n \n import pydicom.pixel_data_handlers.numpy_handler as np_handler  # noqa\n@@ -128,5 +125,8 @@ def debug(debug_on=True):\n         debugging = False\n \n \n-# force level=WARNING, in case logging default is set differently (issue 103)\n-debug(False)\n+# The pydicom logger is configured but not initialized here.\n+# It is up to the client application to configure handlers and levels.\n+\n+\n+\n"
  },
  "pydicom__pydicom-1139": {
    "instance_id": "pydicom__pydicom-1139",
    "model_name_or_path": "nano-workflow",
    "model_patch": ""
  },
  "pydicom__pydicom-1256": {
    "instance_id": "pydicom__pydicom-1256",
    "model_name_or_path": "nano-workflow",
    "model_patch": "diff --git a/pydicom/jsonrep.py b/pydicom/jsonrep.py\nindex c6ef519c3..07b1c466a 100644\n--- a/pydicom/jsonrep.py\n+++ b/pydicom/jsonrep.py\n@@ -226,7 +226,8 @@ class JsonDataElementConverter:\n                     value_key = unique_value_keys[0]\n                     elem = DataElement.from_json(\n                         self.dataset_class, key, vr,\n-                        val[value_key], value_key\n+                        val[value_key], value_key,\n+                        self.bulk_data_element_handler\n                     )\n                 ds.add(elem)\n         return ds\n@@ -271,3 +272,4 @@ class JsonDataElementConverter:\n                 comps[2] = value['Phonetic']\n             elem_value = '='.join(comps)\n             return elem_value\n+\n"
  }
}